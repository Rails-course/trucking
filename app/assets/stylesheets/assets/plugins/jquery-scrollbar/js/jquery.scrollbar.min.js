!(function (l, e) { typeof define === 'function' && define.amd ? define(['../../.rbenv/versions/2.6.8/lib/ruby/gems/2.6.0/gems/jquery-rails-4.5.0/vendor/assets/javascripts/jquery'], e) : e(l.jQuery); }(this, (l) => {
  const e = {
    data: { index: 0, name: 'scrollbar' }, macosx: /mac/i.test(navigator.platform), mobile: /android|webos|iphone|ipad|ipod|blackberry/i.test(navigator.userAgent), overlay: null, scroll: null, scrolls: [], webkit: /webkit/i.test(navigator.userAgent) && !/edge\/\d+/i.test(navigator.userAgent),
  }; e.scrolls.add = function (l) { this.remove(l).push(l); }, e.scrolls.remove = function (e) { for (;l.inArray(e, this) >= 0;) this.splice(l.inArray(e, this), 1); return this; }; const o = {
    autoScrollSize: !0, autoUpdate: !0, debug: !1, disableBodyScroll: !1, duration: 200, ignoreMobile: !1, ignoreOverlay: !1, scrollStep: 30, showArrows: !1, stepScrolling: !0, scrollx: null, scrolly: null, onDestroy: null, onInit: null, onScroll: null, onUpdate: null,
  }; const s = function (s) { let r; e.scroll || (e.overlay = !((r = c(!0)).height || r.width), e.scroll = c(), n(), l(window).resize(() => { let l = !1; if (e.scroll && (e.scroll.height || e.scroll.width)) { const o = c(); o.height === e.scroll.height && o.width === e.scroll.width || (e.scroll = o, l = !0); }n(l); })), this.container = s, this.namespace = `.scrollbar_${e.data.index++}`, this.options = l.extend({}, o, window.jQueryScrollbarOptions || {}), this.scrollTo = null, this.scrollx = {}, this.scrolly = {}, s.data(e.data.name, this), e.scrolls.add(this); }; s.prototype = {
    destroy() {
      if (this.wrapper) {
        this.container.removeData(e.data.name), e.scrolls.remove(this); const o = this.container.scrollLeft(); const s = this.container.scrollTop(); this.container.insertBefore(this.wrapper).css({ height: '', margin: '', 'max-height': '' }).removeClass('scroll-content scroll-scrollx_visible scroll-scrolly_visible').off(this.namespace)
          .scrollLeft(o)
          .scrollTop(s), this.scrollx.scroll.removeClass('scroll-scrollx_visible').find('div').andSelf().off(this.namespace), this.scrolly.scroll.removeClass('scroll-scrolly_visible').find('div').andSelf().off(this.namespace), this.wrapper.remove(), l(document).add('body').off(this.namespace), l.isFunction(this.options.onDestroy) && this.options.onDestroy.apply(this, [this.container]);
      }
    },
    init(o) {
      const s = this; const r = this.container; let t = this.containerWrapper || r; const i = this.namespace; const n = l.extend(this.options, o || {}); const c = { x: this.scrollx, y: this.scrolly }; let d = this.wrapper; const h = { scrollLeft: r.scrollLeft(), scrollTop: r.scrollTop() }; if (e.mobile && n.ignoreMobile || e.overlay && n.ignoreOverlay || e.macosx && !e.webkit) return !1; if (d) {
        t.css({
          height: 'auto', 'margin-bottom': `${-1 * e.scroll.height}px`, 'margin-right': `${-1 * e.scroll.width}px`, 'max-height': '',
        });
      } else {
        if (this.wrapper = d = l('<div>').addClass('scroll-wrapper').addClass(r.attr('class')).css('position', r.css('position') == 'absolute' ? 'absolute' : 'relative')
          .insertBefore(r)
          .append(r), r.is('textarea') && (this.containerWrapper = t = l('<div>').insertBefore(r).append(r), d.addClass('scroll-textarea')), t.addClass('scroll-content').css({
          height: 'auto', 'margin-bottom': `${-1 * e.scroll.height}px`, 'margin-right': `${-1 * e.scroll.width}px`, 'max-height': '',
        }), r.on(`scroll${i}`, (e) => {
          l.isFunction(n.onScroll) && n.onScroll.call(s, {
            maxScroll: c.y.maxScrollOffset, scroll: r.scrollTop(), size: c.y.size, visible: c.y.visible,
          }, {
            maxScroll: c.x.maxScrollOffset, scroll: r.scrollLeft(), size: c.x.size, visible: c.x.visible,
          }), c.x.isVisible && c.x.scroll.bar.css('left', `${r.scrollLeft() * c.x.kx}px`), c.y.isVisible && c.y.scroll.bar.css('top', `${r.scrollTop() * c.y.kx}px`);
        }), d.on(`scroll${i}`, () => { d.scrollTop(0).scrollLeft(0); }), n.disableBodyScroll) { const p = function (l) { a(l) ? c.y.isVisible && c.y.mousewheel(l) : c.x.isVisible && c.x.mousewheel(l); }; d.on(`MozMousePixelScroll${i}`, p), d.on(`mousewheel${i}`, p), e.mobile && d.on(`touchstart${i}`, (e) => { const o = e.originalEvent.touches && e.originalEvent.touches[0] || e; const s = o.pageX; const t = o.pageY; const n = r.scrollLeft(); const c = r.scrollTop(); l(document).on(`touchmove${i}`, (l) => { const e = l.originalEvent.targetTouches && l.originalEvent.targetTouches[0] || l; r.scrollLeft(n + s - e.pageX), r.scrollTop(c + t - e.pageY), l.preventDefault(); }), l(document).on(`touchend${i}`, () => { l(document).off(i); }); }); }l.isFunction(n.onInit) && n.onInit.apply(this, [r]);
      }l.each(c, (e, o) => {
        let t = null; let d = 1; const h = e === 'x' ? 'scrollLeft' : 'scrollTop'; let p = n.scrollStep; const u = function () { let l = r[h](); r[h](l + p), d == 1 && l + p >= f && (l = r[h]()), d == -1 && l + p <= f && (l = r[h]()), r[h]() == l && t && t(); }; var f = 0; o.scroll || (o.scroll = s._getScroll(n[`scroll${e}`]).addClass(`scroll-${e}`), n.showArrows && o.scroll.addClass('scroll-element_arrows_visible'), o.mousewheel = function (l) { if (!o.isVisible || e === 'x' && a(l)) return !0; if (e === 'y' && !a(l)) return c.x.mousewheel(l), !0; const t = -1 * l.originalEvent.wheelDelta || l.originalEvent.detail; const i = o.size - o.visible - o.offset; return (t > 0 && f < i || t < 0 && f > 0) && ((f += t) < 0 && (f = 0), f > i && (f = i), s.scrollTo = s.scrollTo || {}, s.scrollTo[h] = f, setTimeout(() => { s.scrollTo && (r.stop().animate(s.scrollTo, 240, 'linear', () => { f = r[h](); }), s.scrollTo = null); }, 1)), l.preventDefault(), !1; }, o.scroll.on(`MozMousePixelScroll${i}`, o.mousewheel).on(`mousewheel${i}`, o.mousewheel).on(`mouseenter${i}`, () => { f = r[h](); }), o.scroll.find('.scroll-arrow, .scroll-element_track').on(`mousedown${i}`, function (i) {
          if (i.which != 1) return !0; d = 1; const c = {
            eventOffset: i[e === 'x' ? 'pageX' : 'pageY'], maxScrollValue: o.size - o.visible - o.offset, scrollbarOffset: o.scroll.bar.offset()[e === 'x' ? 'left' : 'top'], scrollbarSize: o.scroll.bar[e === 'x' ? 'outerWidth' : 'outerHeight'](),
          }; let a = 0; let v = 0; return l(this).hasClass('scroll-arrow') ? (d = l(this).hasClass('scroll-arrow_more') ? 1 : -1, p = n.scrollStep * d, f = d > 0 ? c.maxScrollValue : 0) : (d = c.eventOffset > c.scrollbarOffset + c.scrollbarSize ? 1 : c.eventOffset < c.scrollbarOffset ? -1 : 0, p = Math.round(0.75 * o.visible) * d, f = c.eventOffset - c.scrollbarOffset - (n.stepScrolling ? d == 1 ? c.scrollbarSize : 0 : Math.round(c.scrollbarSize / 2)), f = r[h]() + f / o.kx), s.scrollTo = s.scrollTo || {}, s.scrollTo[h] = n.stepScrolling ? r[h]() + p : f, n.stepScrolling && (t = function () { f = r[h](), clearInterval(v), clearTimeout(a), a = 0, v = 0; }, a = setTimeout(() => { v = setInterval(u, 40); }, n.duration + 100)), setTimeout(() => { s.scrollTo && (r.animate(s.scrollTo, n.duration), s.scrollTo = null); }, 1), s._handleMouseDown(t, i);
        }), o.scroll.bar.on(`mousedown${i}`, (t) => { if (t.which != 1) return !0; const n = t[e === 'x' ? 'pageX' : 'pageY']; const c = r[h](); return o.scroll.addClass('scroll-draggable'), l(document).on(`mousemove${i}`, (l) => { const s = parseInt((l[e === 'x' ? 'pageX' : 'pageY'] - n) / o.kx, 10); r[h](c + s); }), s._handleMouseDown(() => { o.scroll.removeClass('scroll-draggable'), f = r[h](); }, t); }));
      }), l.each(c, (l, e) => { const o = `scroll-scroll${l}_visible`; const s = l == 'x' ? c.y : c.x; e.scroll.removeClass(o), s.scroll.removeClass(o), t.removeClass(o); }), l.each(c, (e, o) => { l.extend(o, e == 'x' ? { offset: parseInt(r.css('left'), 10) || 0, size: r.prop('scrollWidth'), visible: d.width() } : { offset: parseInt(r.css('top'), 10) || 0, size: r.prop('scrollHeight'), visible: d.height() }); }), this._updateScroll('x', this.scrollx), this._updateScroll('y', this.scrolly), l.isFunction(n.onUpdate) && n.onUpdate.apply(this, [r]), l.each(c, (l, e) => { const o = l === 'x' ? 'left' : 'top'; const s = l === 'x' ? 'outerWidth' : 'outerHeight'; const t = l === 'x' ? 'width' : 'height'; const i = parseInt(r.css(o), 10) || 0; const c = e.size; const a = e.visible + i; const d = e.scroll.size[s]() + (parseInt(e.scroll.size.css(o), 10) || 0); n.autoScrollSize && (e.scrollbarSize = parseInt(d * a / c, 10), e.scroll.bar.css(t, `${e.scrollbarSize}px`)), e.scrollbarSize = e.scroll.bar[s](), e.kx = (d - e.scrollbarSize) / (c - a) || 1, e.maxScrollOffset = c - a; }), r.scrollLeft(h.scrollLeft).scrollTop(h.scrollTop).trigger('scroll');
    },
    _getScroll(e) { const o = { advanced: ['<div class="scroll-element">', '<div class="scroll-element_corner"></div>', '<div class="scroll-arrow scroll-arrow_less"></div>', '<div class="scroll-arrow scroll-arrow_more"></div>', '<div class="scroll-element_outer">', '<div class="scroll-element_size"></div>', '<div class="scroll-element_inner-wrapper">', '<div class="scroll-element_inner scroll-element_track">', '<div class="scroll-element_inner-bottom"></div>', '</div>', '</div>', '<div class="scroll-bar">', '<div class="scroll-bar_body">', '<div class="scroll-bar_body-inner"></div>', '</div>', '<div class="scroll-bar_bottom"></div>', '<div class="scroll-bar_center"></div>', '</div>', '</div>', '</div>'].join(''), simple: ['<div class="scroll-element">', '<div class="scroll-element_outer">', '<div class="scroll-element_size"></div>', '<div class="scroll-element_track"></div>', '<div class="scroll-bar"></div>', '</div>', '</div>'].join('') }; return o[e] && (e = o[e]), e || (e = o.simple), e = typeof e === 'string' ? l(e).appendTo(this.wrapper) : l(e), l.extend(e, { bar: e.find('.scroll-bar'), size: e.find('.scroll-element_size'), track: e.find('.scroll-element_track') }), e; },
    _handleMouseDown(e, o) { const s = this.namespace; return l(document).on(`blur${s}`, () => { l(document).add('body').off(s), e && e(); }), l(document).on(`dragstart${s}`, (l) => (l.preventDefault(), !1)), l(document).on(`mouseup${s}`, () => { l(document).add('body').off(s), e && e(); }), l('body').on(`selectstart${s}`, (l) => (l.preventDefault(), !1)), o && o.preventDefault(), !1; },
    _updateScroll(o, s) { const r = this.container; const t = this.containerWrapper || r; const i = `scroll-scroll${o}_visible`; const n = o === 'x' ? this.scrolly : this.scrollx; const c = parseInt(this.container.css(o === 'x' ? 'left' : 'top'), 10) || 0; const a = this.wrapper; const d = s.size; const h = s.visible + c; s.isVisible = d - h > 1, s.isVisible ? (s.scroll.addClass(i), n.scroll.addClass(i), t.addClass(i)) : (s.scroll.removeClass(i), n.scroll.removeClass(i), t.removeClass(i)), o === 'y' && (r.is('textarea') || d < h ? t.css({ height: `${h + e.scroll.height}px`, 'max-height': 'none' }) : t.css({ 'max-height': `${h + e.scroll.height}px` })), s.size == r.prop('scrollWidth') && n.size == r.prop('scrollHeight') && s.visible == a.width() && n.visible == a.height() && s.offset == (parseInt(r.css('left'), 10) || 0) && n.offset == (parseInt(r.css('top'), 10) || 0) || (l.extend(this.scrollx, { offset: parseInt(r.css('left'), 10) || 0, size: r.prop('scrollWidth'), visible: a.width() }), l.extend(this.scrolly, { offset: parseInt(r.css('top'), 10) || 0, size: this.container.prop('scrollHeight'), visible: a.height() }), this._updateScroll(o === 'x' ? 'y' : 'x', n)); },
  }; const r = s; l.fn.scrollbar = function (o, s) { return typeof o !== 'string' && (s = o, o = 'init'), void 0 === s && (s = []), l.isArray(s) || (s = [s]), this.not('body, .scroll-wrapper').each(function () { const t = l(this); let i = t.data(e.data.name); (i || o === 'init') && (i || (i = new r(t)), i[o] && i[o].apply(i, s)); }), this; }, l.fn.scrollbar.options = o; let t; let i; var n = (t = 0, function (l) {
    let o; let s; let r; let i; let c; let a; let d; for (o = 0; o < e.scrolls.length; o++) {
      s = (i = e.scrolls[o]).container, r = i.options, c = i.wrapper, a = i.scrollx, d = i.scrolly, (l || r.autoUpdate && c && c.is(':visible') && (s.prop('scrollWidth') != a.size || s.prop('scrollHeight') != d.size || c.width() != a.visible || c.height() != d.visible)) && (i.init(), r.debug && window.console && console.log({
        scrollHeight: `${s.prop('scrollHeight')}:${i.scrolly.size}`, scrollWidth: `${s.prop('scrollWidth')}:${i.scrollx.size}`, visibleHeight: `${c.height()}:${i.scrolly.visible}`, visibleWidth: `${c.width()}:${i.scrollx.visible}`,
      }, !0));
    } clearTimeout(t), t = setTimeout(n, 300);
  }); function c(o) {
    if (e.webkit && !o) return { height: 0, width: 0 }; if (!e.data.outer) {
      const s = {
        border: 'none', 'box-sizing': 'content-box', height: '200px', margin: '0', padding: '0', width: '200px',
      }; e.data.inner = l('<div>').css(l.extend({}, s)), e.data.outer = l('<div>').css(l.extend({
        left: '-1000px', overflow: 'scroll', position: 'absolute', top: '-1000px',
      }, s)).append(e.data.inner).appendTo('body');
    } return e.data.outer.scrollLeft(1e3).scrollTop(1e3), { height: Math.ceil(e.data.outer.offset().top - e.data.inner.offset().top || 0), width: Math.ceil(e.data.outer.offset().left - e.data.inner.offset().left || 0) };
  } function a(l) { const e = l.originalEvent; return (!e.axis || e.axis !== e.HORIZONTAL_AXIS) && !e.wheelDeltaX; }window.angular && (i = window.angular).module('jQueryScrollbar', []).provider('jQueryScrollbar', () => { const l = o; return { setOptions(e) { i.extend(l, e); }, $get() { return { options: i.copy(l) }; } }; }).directive('jqueryScrollbar', ['jQueryScrollbar', '$parse', function (l, e) { return { restrict: 'AC', link(o, s, r) { const t = e(r.jqueryScrollbar)(o); s.scrollbar(t || l.options).on('$destroy', () => { s.scrollbar('destroy'); }); } }; }]);
}));
